import mongoose, { Schema, Document, Model } from 'mongoose';

/**
 * SKU Recommendation Model
 * 
 * PURPOSE:
 * - Store AI/ML-powered recommendations for SKUs
 * - Recommendations for pricing, promotions, restocking, delisting
 * - One recommendation per SKU per recommendation type per scope
 * - Can be updated as new data comes in
 * 
 * RULES:
 * - Recommendations are generated by ML models or rule engines
 * - Can be updated when new data arrives
 * - Includes confidence scores and reasoning
 */

export type RecommendationType = 'price_increase' | 'price_decrease' | 'promote' | 'restock' | 'delist' | 'bundle';
export type RecommendationStatus = 'pending' | 'accepted' | 'rejected' | 'expired';

export interface ISKURecommendation extends Document {
  _id: mongoose.Types.ObjectId;
  storeId: mongoose.Types.ObjectId;
  scope: 'admin' | 'supplier' | 'reseller';
  entityId?: mongoose.Types.ObjectId | string | null;
  skuId: mongoose.Types.ObjectId;
  sku: string;
  productId: mongoose.Types.ObjectId;

  // Recommendation details
  recommendationType: RecommendationType;
  status: RecommendationStatus;
  priority: 'low' | 'medium' | 'high' | 'urgent';

  // Recommendation content
  title: string;
  description: string;
  reasoning: string; // Why this recommendation was made
  confidence: number; // 0-100 confidence score

  // Action details
  suggestedPrice?: number; // For price recommendations
  suggestedDiscount?: number; // For promotion recommendations
  suggestedQuantity?: number; // For restock recommendations
  suggestedBundle?: {
    skuIds: mongoose.Types.ObjectId[];
    bundlePrice: number;
  };

  // Expected impact
  expectedRevenueImpact?: number;
  expectedOrderImpact?: number;
  expectedMarginImpact?: number;

  // Metadata
  modelVersion?: string; // ML model version that generated this
  dataPoints?: Record<string, any>; // Supporting data
  expiresAt?: Date; // When recommendation expires

  // Tracking
  viewedAt?: Date;
  actionedAt?: Date;
  actionedBy?: mongoose.Types.ObjectId | string;

  createdAt: Date;
  updatedAt: Date;
}

const SKURecommendationSchema: Schema = new Schema(
  {
    storeId: {
      type: Schema.Types.ObjectId,
      ref: 'Store',
      required: [true, 'Store ID is required'],
      index: true,
    },
    scope: {
      type: String,
      enum: ['admin', 'supplier', 'reseller'],
      required: [true, 'Scope is required'],
      index: true,
    },
    entityId: {
      type: Schema.Types.Mixed,
      default: null,
      index: true,
    },
    skuId: {
      type: Schema.Types.ObjectId,
      ref: 'ProductVariant',
      required: [true, 'SKU ID is required'],
      index: true,
    },
    sku: {
      type: String,
      required: [true, 'SKU is required'],
      uppercase: true,
      trim: true,
      index: true,
    },
    productId: {
      type: Schema.Types.ObjectId,
      ref: 'Product',
      required: [true, 'Product ID is required'],
      index: true,
    },
    recommendationType: {
      type: String,
      enum: ['price_increase', 'price_decrease', 'promote', 'restock', 'delist', 'bundle'],
      required: [true, 'Recommendation type is required'],
      index: true,
    },
    status: {
      type: String,
      enum: ['pending', 'accepted', 'rejected', 'expired'],
      default: 'pending',
      index: true,
    },
    priority: {
      type: String,
      enum: ['low', 'medium', 'high', 'urgent'],
      default: 'medium',
      index: true,
    },
    title: {
      type: String,
      required: [true, 'Title is required'],
    },
    description: {
      type: String,
      required: [true, 'Description is required'],
    },
    reasoning: {
      type: String,
      required: [true, 'Reasoning is required'],
    },
    confidence: {
      type: Number,
      required: true,
      min: 0,
      max: 100,
      index: true,
    },
    suggestedPrice: {
      type: Number,
      min: 0,
    },
    suggestedDiscount: {
      type: Number,
      min: 0,
      max: 100,
    },
    suggestedQuantity: {
      type: Number,
      min: 0,
    },
    suggestedBundle: {
      skuIds: [{ type: Schema.Types.ObjectId, ref: 'ProductVariant' }],
      bundlePrice: Number,
    },
    expectedRevenueImpact: {
      type: Number,
    },
    expectedOrderImpact: {
      type: Number,
    },
    expectedMarginImpact: {
      type: Number,
    },
    modelVersion: {
      type: String,
    },
    dataPoints: {
      type: Schema.Types.Mixed,
      default: {},
    },
    expiresAt: {
      type: Date,
      index: true,
    },
    viewedAt: {
      type: Date,
    },
    actionedAt: {
      type: Date,
    },
    actionedBy: {
      type: Schema.Types.Mixed,
    },
  },
  {
    timestamps: true,
  }
);

// Compound indexes
SKURecommendationSchema.index({ storeId: 1, scope: 1, status: 1, priority: -1 });
SKURecommendationSchema.index({ storeId: 1, scope: 1, entityId: 1, skuId: 1, recommendationType: 1 });
SKURecommendationSchema.index({ skuId: 1, status: 1, createdAt: -1 });
SKURecommendationSchema.index({ recommendationType: 1, status: 1, confidence: -1 });

// Unique constraint: one active recommendation per type per SKU
SKURecommendationSchema.index(
  { storeId: 1, scope: 1, entityId: 1, skuId: 1, recommendationType: 1, status: 1 },
  { unique: true, partialFilterExpression: { status: 'pending' } }
);

export const SKURecommendation: Model<ISKURecommendation> =
  mongoose.models.SKURecommendation || mongoose.model<ISKURecommendation>('SKURecommendation', SKURecommendationSchema);

